
Design Overview

<img src="https://i.ibb.co/T8x7nVz/Picture1.png" alt="Picture1" border="0">

The architecture of our project is divided into two main parts: a frontend client and a backend client. The frontend client provides an interface through which the end user can interact with the system without needing to know about blockchain specifics. Actions such as file upload, file download and mining blocks for credits are initiated by the frontend and sent to the backend via a web API.
Once the backend receives a request from the frontend client, the request is translated and propagated across a series of blockchain nodes. Each node has its own blockchain and makes a decision whether to accept or reject the request. If the request is accepted by a majority of nodes, each node logs the request in their blockchain and the request is then forwarded to the secure file vault. In our implementation these nodes are simulated in order to conserve development time that would be spent on networking. 


MVC

<img src="https://i.ibb.co/4mc4JkX/mvc.png" alt="mvc" border="0">

The project’s frontend is built around the Model View Controller (MVC) design pattern. Following the MVC design enables clean and manageable program components. 

The model represents the data structures utilized throughout the program and manages much of the application data. The controller manipulates each instance of the data by updating and assigning internal data from the instances to the view components. In ACCloud, there are seven models within the parent package.

The view is the FXML formatted file that is denoted with tags throughout its code. Each view has a controller class that updates it with data from multiple sources including the model. There are six different views including the main view, backup view, ed view, login view, split merge view, and create account view.

The controller contains multiple controllers that use native and our own data models to update each view when the user interacts with the application. The controller also handles automated functions such as the API calls for the block verification and autobackups.



Local File Tree

<img src="https://i.ibb.co/bmtxbx3/local-gen-file-tree.png" alt="local-gen-file-tree" border="0">

In the local tree, the host name is generated by obtaining the Inet address which is the host computer name. Then, the hostname is used as the root node in the file tree. The file system’s root directories must be loaded into an iterable object. After, each directory is added to the root node as child nodes. The FileTreePathItem class handles the building of the subtree for each of those directories.

The general tree above shows the root node at the top, level 0. The nodes at level 1 are the root directories and their children are built once the user interacts with the file tree.

Encryption process

<img src="https://i.ibb.co/BVtgbJk/encrypt.png" alt="encrypt" border="0">

When the user initiates an upload or manual file encryption, the EDTool class is instantiated and the encrypt() method is called. The most paramount phase of the method is using a cipher to translate the file’s raw binary data into incomprehensible data. The cipher must be given a secret key which contains parameters from the keyspec that make the encryption algorithm more effective. The user password that is specified by the client is factored into the encryption process. The salt is some random data that is generated by the secureRandom instance. The iteration count, which was set to 6536 (int),  represents the number of times the password is hashed for the keyspec. Lastly, the key length is measured in bits and is set to 256, which is one common standard for Advanced Encryption Standard (AES). Once the key spec is determined and the key is generated, the cipher uses the key to encrypt the data. The parameters for the key must be sent to the server, otherwise the data cannot be decrypted. 


<img src="https://i.ibb.co/3WK84ZT/encrypt-2.png" alt="encrypt-2" border="0">

Before the cipher can be used, the data must be in a raw processable format. The fileInputStream and bufferedInputStream enable quick file reading into a buffer. Then, through each iteration of a loop the cipher translates the data.


<img src="https://i.ibb.co/kX8ZCns/encrypt-3.png" alt="encrypt-3" border="0">

Lastly, the data will be sent to the fileOutputStream and written to an instance of the EncryptedFile model class


Decryption process

<img src="https://i.ibb.co/tLxWhdq/decrypt-1.png" alt="decrypt-1" border="0">

The decryption method is similar to the encryption process, but the server will provide the parameters through the JSON data response. The keyspec is loaded with the same inputs and the cipher is instantiated.

<img src="https://i.ibb.co/yRy3TFz/decrypt-2.png" alt="decrypt-2" border="0">

The cipher mode is set to decrypt and the data goes through the same iterative process described in the encryption section.

Encoding

The Apache commons library was utilized to allow the file and salt to be encoded and decoded. The request body contains string, int and long values. Once the encoding is performed, the data is bound to the encryptedFile. The decoding enables the keyspec to function properly when using the salt.

<img src="https://i.ibb.co/Ybk2W8F/encoding.png" alt="encoding" border="0">

The file inputstream is passed the encrypted data which is loaded in the iterative process into the buffer. Each iteration performs a base64 algorithm.

<img src="https://i.ibb.co/rmmxPSy/encoding-2png.png" alt="encoding-2png" border="0">

The raw binary data is divided into 3 bytes and then further divided into 6 bit numbers. Each number can be between 0-63. The ASCII table provides a translation for the numbers so a string can be generated. An example can be viewed below:

EX:

10011011
10100010
11101001

100110 => 38
111010 => 58
001011 => 11
101001 => 41

38 => m
58 => 6
11 => L
41 -> p


Decoding

<img src="https://i.ibb.co/pXwcM2t/decoding.png" alt="decoding" border="0">

The decoding process operates similarly to the encoding process, but the file string and salt are provided through JSON response. Once the data is parsed, it goes through a reversed base64 process.


EX:

m => 38 
6  => 58 
L  => 11 
p  => 41 

38 => 100110 
58 => 111010
11 => 001011 
41 => 101001

10011011 
10100010  
11101001  


Webcontroller

<img src="https://i.ibb.co/VJBkR2q/webcontroller.png" alt="webcontroller" border="0">

The WebController class contains all of the methods for sending requests to the server for:

Uploading single files
Uploading directories
Downloading files
Remotely deleting files
Retrieving the blockchain
Retrieving the work
Submitting work
Retrieving user data

All of these methods rely on the OkHttpClient to send composed JSON data to the server and to receive it from the server. The upload methods pull data from the encrypted file passed to it and concatenates it to the string in the request body. The URL is designated by the API documentation and bundled with the request. When data is downloaded, the user id is used to download the list of files. When the user decides to download a file the id is passed and a request is made to the server for that file. All other methods function similarly. 


Blockchain

<img src="https://i.ibb.co/NWKnpPt/blockchain.png" alt="blockchain" border="0" />

In a blockchain network, the transaction is a basic unit of information storage. In its most basic form a transaction is an object that contains two attributes: a value field that is a string representation of information for transport and a hash field containing a SHA-256 hash of the value field. As long as these two constraints are met, there is no limit to what can be placed in the value field. In cryptocurrencies, the information stored in transactions would be the sender, recipient, amount of currency, and timestamp of a given currency transaction (hence the name).
	Our implementation leverages the transaction model as a means to log all requests to a secure file vault. The blockchain network acts as an intermediary that must be passed through in order to perform operations on files in the secure vault. In this way, event logs are distributed to a blockchain network that is difficult to tamper with. Operations such as file creation, file access and file deletion are implemented in our prototype, but the flexibility of the transaction model allows for any number of future events to be added.


Blocks

<img src="https://i.ibb.co/44wVzgk/blocks.png" alt="blocks" border="0">

Performance

<img src="https://i.ibb.co/CQnt39K/performance-2.png" alt="performance-2" border="0">

The above table demonstrates the impact of adjusting the pattern that a block hash must conform to in order to be considered part of a blockchain. As the pattern becomes more restrictive, the amount of iterations and therefore time needed to mine the block increases drastically. The first three rows had low performance impact relative to the baseline API request. However, starting from the fourth row the API becomes extremely unresponsive and the sixth row encounters PHP’s script timeout limit. With a relatively secure Proof of Work algorithm targeting around a 20 minute mining time, future work will need to include solving this issue with an asynchronous approach.

<img src="https://i.ibb.co/CQnt39K/performance-2.png" alt="performance-2" border="0">

Outside of block mining, the response sizes and latencies of our backend are within the expected parameters of a standard web API. However, since blockchains can potentially grow forever, mechanisms may be needed in the future to either compact or split blockchains at certain size thresholds.


Demo

Click below for a demo of the application

[![Watch the video](https://i.ibb.co/J2zrrwS/Screen-Shot-2021-04-08-at-7-01-01-PM.png)](https://www.youtube.com/watch?v=g4zP_nFASZA)

